## Практические задания по сериализации и десериализации в FastAPI

### Введение

Откройте проект с прошлого урока из exercise_2 с книгами.

### Задание 1: Отправка неполных данных

**Задание:**
Отправьте POST-запрос на `/books` с телом, в котором отсутствует обязательное поле `title`.

**Неправильный запрос:**
```json
{
  "author": "Some Author"
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `422 Unprocessable Entity` и сообщением об ошибке, указывающим, что поле `title` является обязательным.

**Исправленный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
}
```

### Задание 2: Отправка данных с неверным типом

**Задание:**
Отправьте POST-запрос на `/books` с телом, в котором поле `title` имеет неверный тип данных (например, число вместо строки).

**Неправильный запрос:**
```json
{
  "title": 12345,
  "author": "Some Author"
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `422 Unprocessable Entity` и сообщением об ошибке, указывающим, что поле `title` должно быть строкой.

**Исправленный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
}
```

### Задание 3: Отправка данных с несуществующим полем

**Задание:**
Отправьте PUT-запрос на `/books/{book_id}` с телом, содержащим несуществующее поле (например, `publisher`).

**Неправильный запрос:**
```json
{
  "title": "Updated Book Title",
  "author": "New Author",
  "publisher": "Some Publisher"
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `422 Unprocessable Entity` и сообщением об ошибке, указывающим, что поле `publisher` является лишним.

**Исправленный запрос:**
```json
{
  "title": "Updated Book Title",
  "author": "New Author"
}
```

**Примечание:**
Чтобы заставить Pydantic выдавать ошибку при наличии лишних полей, нужно использовать параметр `extra=Extra.forbid` в модели Pydantic. Это заставит Pydantic выдавать ошибку, если в JSON будут лишние поля.

**Исправленный код модели:**
```python
from pydantic import BaseModel, Extra

class Book(BaseModel):
    title: str
    author: str | None = None

    class Config:
        extra = Extra.forbid
```

### Задание 4: Отправка данных с неверным форматом JSON

**Задание:**
Отправьте POST-запрос на `/books` с телом, содержащим неверный формат JSON (например, отсутствует закрывающая фигурная скобка).

**Неправильный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `400 Bad Request` и сообщением об ошибке, указывающим, что тело запроса имеет неверный формат JSON.

**Исправленный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
}
```

### Задание 5: Попытка обновления несуществующей книги

**Задание:**
Отправьте PUT-запрос на `/books/{book_id}` с несуществующим `book_id`.

**Неправильный запрос:**
```
PUT http://127.0.0.1:8000/books/999
{
  "title": "Updated Book Title",
  "author": "New Author"
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `404 Not Found` и сообщением об ошибке, указывающим, что книга не найдена.

**Исправленный запрос:**
Используйте существующий `book_id`, например:
```
PUT http://127.0.0.1:8000/books/1
{
  "title": "Updated Book Title",
  "author": "New Author"
}
```

### Задание 6: Отправка данных с пустыми значениями

**Задание:**
Отправьте POST-запрос на `/books` с телом, в котором поле `title` является пустой строкой.

**Неправильный запрос:**
```json
{
  "title": "",
  "author": "Some Author"
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `422 Unprocessable Entity` и сообщением об ошибке, указывающим, что поле `title` не может быть пустым.

**Исправленный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
}
```

**Примечание:**
Чтобы заставить Pydantic выдавать ошибку при получении пустой строки, нужно добавить валидацию, которая проверяет, что строка не пустая. Это можно сделать с помощью валидатора в модели Pydantic.

**Исправленный код модели:**
```python
from pydantic import BaseModel, validator, ValidationError

class Book(BaseModel):
    title: str
    author: str | None = None

    @validator('title')
    def title_not_empty(cls, value):
        if not value.strip():
            raise ValueError('Title must not be empty')
        return value
```

### Задание 7: Отправка данных с неверным типом в необязательном поле

**Задание:**
Отправьте POST-запрос на `/books` с телом, в котором необязательное поле `author` имеет неверный тип данных (например, число вместо строки).

**Неправильный запрос:**
```json
{
  "title": "Book Title",
  "author": 12345
}
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `422 Unprocessable Entity` и сообщением об ошибке, указывающим, что поле `author` должно быть строкой.

**Исправленный запрос:**
```json
{
  "title": "Book Title",
  "author": "Some Author"
}
```

### Задание 8: Попытка удаления несуществующей книги

**Задание:**
Отправьте DELETE-запрос на `/books/{book_id}` с несуществующим `book_id`.

**Неправильный запрос:**
```
DELETE http://127.0.0.1:8000/books/999
```

**Ожидаемый ответ:**
Сервер должен вернуть ответ с кодом состояния `404 Not Found` и сообщением об ошибке, указывающим, что книга не найдена.

**Исправленный запрос:**
Используйте существующий `book_id`, например:
```
DELETE http://127.0.0.1:8000/books/1
```